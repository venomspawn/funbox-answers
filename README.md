# Ответы на вопросы в подборке квалификационных заданий от FunBox

Данный документ содержит ответы на вопросы в [подборке квалификационных заданий
от FunBox](https://dl.funbox.ru/qt-ruby.pdf). Ответы разбиты на секции так же,
как вопросы и задания в оригинальной подборке. Для удобства проверки в секциях
`Level I` и `Level II` приведены исходные вопросы и задания. В секции `Level
III` приведены только ссылки на репозитории с решениями задач.

## Level I

### Q1

**Вопрос**. Чем отличается `proc` от `lambda`?

**Ответ**. Основное отличие заключается в том, как ведёт себя объект типа
`Proc`, возвращённый `proc` или `lambda`, при вызове метода `call` или его
псевдонимов. Так, если объект типа `Proc` был возвращён `proc`, то при вызове
`call` этого объекта лишние аргументы метода будут проигнорированы, а
недостающие — инициализированы `nil`. Если же объект был возвращён `lambda`, то
при вызове `call` с лишними или недостающими аргументами будет создано
исключение класса `ArgumentError`. Дополнительное отличие заключается в
результате вызова метода `lambda?` у указанных объектов: для результата `proc`
метод возвратит булево значение `false`, а для результата `lambda` — булево
значение `true`.

### Q2

**Вопрос**. Чем отличается `&&` от `and`?

**Ответ**. Несмотря на то, что семантически эти операторы представляют собой
одно и то же, оператор `&&` имеет более высокий приоритет, нежели `and`. Более
того, между ними в [таблице приоритетов операторов
Ruby](https://ruby-doc.org/core-2.5.3/doc/syntax/precedence_rdoc.html)
находятся и другие важные операторы (например, `=`), что приводит к большой
путанице при использовании `and`. Так, выражение
```ruby
a = b and c
```

фактически означает
```ruby
(a = b) and c
```

что сильно сбивает с толку.

### Q3

**Вопрос**. Какие плюсы и минусы по сравнению с другими современными языками
программирования вы выделяете для себя?

**Ответ**. Плюсы:
*   красивый, лаконичный синтаксис;
*   мощные инструменты объектно-ориентированного программирования и
    метапрограммирования;
*   достаточно богатая коллекция встроенных классов и классов стандартной
    бибилотеки;
*   достаточно большое количество готовых библиотек для решения задач при
    написании сетевых сервисов.

Минусы:
*   медлительность (например, каждый вызов метода — это поиск в одной или
    нескольких хэш-таблицах), отсутствие JIT-компиляции;
*   прожорливость в плане потребления памяти (например, массив из миллиона
    попарно различных UUID занимает 81 мегабайт памяти, что в почти в два раза
    больше, чем в C или в Go);
*   громоздкость многопоточной модели стандартного интерпретатора (глобальная
    блокировка интерпретатора в модели синхронизации потоков, невозможность
    запуска потоков на различных ядрах вычислительного устройства, каждый
    объект класса `Thread` занимает мегабайт памяти и так далее);
*   использование в подавляющем большинстве случаев только для написания
    сетевых сервисов;
*   сведение всей разработки к разработке под Rails;
*   низкий порог вхождения.

### Q4

**Вопрос**. В каком случае вы бы стали использовать Ruby on Rails для
разработки web-приложения, а в каком случае — другой фреймворк?

**Ответ**. Я бы использовал Ruby on Rails в том случае, если нужно написать
большое web-приложение, предоставляющее пользователю сложный графический
интерфейс. Такие приложения обычно требуют специальных механизмов (например,
обработку cookie, работу с электронными письмами и так далее), которые идут
непосредственно в поставке Rails. Примеры подобных web-приложений:
интернет-магазины, сайты новостей, платформы обучения через Интернет.

В случае, если приложение имеет очень простой графический интерфейс или не
имеет графического интерфейса вообще, я бы обратился к другим фреймворкам.
Примеры подобных web-приложений: сервисы домашней или промышленной
автоматизации.

### Q5

**Вопрос**. Вы запустили большой и сложный Ruby-скрипт на вашем любимом
дистрибутиве Linux, и в процессе работы он намертво «зависает». Как найти
причину сбоя?

**Ответ**. Для начала я бы добавил `puts` с разными строками здесь и там в
скрипте, чтобы понять, где он зависает. В запущенных случаях использовал бы
интерактивную отладку, например, с помощью библиотеки `byebug`.

### Q6

**Вопрос**. Вы запустили большой и сложный Ruby-скрипт на вашем любимом
дистрибутиве Linux, и в процессе работы он умирает, исчерпав память, хотя,
казалось бы, не должен. Как найти причину сбоя?

**Ответ**. Возможны два варианта причины исчерпания памяти: создание объектов в
слишком больших количествах или создание объектов, которые потребляют слишком
много памяти. В первом случае необходимо искать код, который может во множестве
порождать объекты (например, запрос к базе данных на извлечение записей). Во
втором случае следует искать код, где данные добавляются в экземпляры классов
`String`, `Array`, `Hash` (например, загрузка содержимого файла или добавление
чисел в массивы). В качестве вспомогательных средств можно использовать
возможности модуля `ObjectSpace`:
```ruby
require 'objspace'

count = lambda do |c|
  ObjectSpace.each_object(c).inject(0) { |memo| memo + 1 }
end

memsize = lambda do |c|
  ObjectSpace.each_object(c).inject(0) do |memo, o|
    memo + ObjectSpace.memsize_of(o)
  end
end

puts count[String]
puts memsize[Array]
```

### Q7

**Вопрос**. Некоторые проекты (Rails и не только) мы запускаем под JRuby. Как
вы думаете, почему?

**Ответ**. В моём представлении возможны следующие варианты.
1.  JRuby используется из-за модели потоков Java, которая более эффективна,
    нежели используемая MRI, из-за отсутствия глобальной блокировки
    интерпретатора и эффективного использования потоков операционной системы,
    которые могут распределяться по многим ядрам вычислительного устройства.
2.  JRuby используется из-за AOT- или JIT-компиляции, что позволяет повысить
    скорость выполнения Ruby-кода.
3.  JRuby используется для подключения и использования некоторого Java-кода в
    Ruby-коде. Знаком с подобной ситуацией на примере адаптера системы
    межведомственного электронного взаимодействия: основная библиотека была
    доступна только для Java.

Разумеется, эти варианты нисколько не исключают друг друга.

### Q8

**Вопрос**. Какие плюсы и минусы библиотеки ActiveRecord в Rails вы знаете?
Какие альтернативы существуют? В чём их плюсы и минусы? Какие из них вы
использовали?

**Ответ**. Кроме ActiveRecord, в профессиональной деятельности я использовал
библиотеки Sequel и DataMapper, наиболее знаком с Sequel.

DataMapper уже несколько лет не поддерживается сообществом, что является его
основным минусом. Механизм автомиграций DataMapper, возможно, был плюсом для
новичков, но в больших проектах всё равно приходилось использовать миграции
базы данных.

Основными плюсами ActiveRecord является его поставка с Rails и интеграция с ним
многих библиотек (все эти `has_secure_password` в модели пользователя). Из
минусов хотел бы отметить следующее:
*   недостаточность библиотеки составления запросов Arel, что приводит к тому,
    что использование SQL-текста для построения запросов быстрее и проще;
*   недостаточность средств для написания миграций, что приводит к тому, что
    приходится писать SQL;
*   бесполезный файл `db/schema.rb`;
*   слабая поддержка специфичных команд СУБД, например, `NOTIFY`/`LISTEN` у
    PostgreSQL.

В Sequel я нахожу всё то, чего мне не хватает в ActiveRecord, и в нём нет
`db/schema.rb`. DSL для создания запросов и миграций в Sequel — это его большой
плюс. Также в Sequel отличная поддержка специфичных для PostgreSQL вещей,
включая вышеупомянутые `NOTIFY`/`LISTEN`, `COPY` и прочее. Из минусов могу
отметить отвратный исходный код, в котором иногда сам чёрт ногу сломит.
