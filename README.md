# Ответы на вопросы в подборке квалификационных заданий от FunBox

Данный документ содержит ответы на вопросы в [подборке квалификационных заданий
от FunBox](https://dl.funbox.ru/qt-ruby.pdf). Ответы разбиты на секции так же,
как вопросы и задания в оригинальной подборке. Для удобства проверки в секциях
`Level I` и `Level II` приведены исходные вопросы и задания. В секции `Level
III` приведены только ссылки на репозитории с решениями задач.

## Level I

### Q1

**Вопрос**. Чем отличается `proc` от `lambda`?

**Ответ**. Можнно привести следующие отличия.

1.  Поведение, при вызове метода `call` или его псевдонимов. Так, если объект
    типа `Proc` был возвращён `proc`, то при вызове `call` этого объекта лишние
    аргументы метода будут проигнорированы, а недостающие — инициализированы
    `nil`. Если же объект был возвращён `lambda`, то при вызове `call` с
    лишними или недостающими аргументами будет создано исключение класса
    `ArgumentError`.

2.  Поведение конструкции `return` в блоке-аргументе при создании. Выполнение
    `return` в блоке-аргументе `proc` приведёт к немедленному возврату из
    ближайшего содержащего метода или блока-аргумента `lambda`, где происходит
    определение. Если возврат невозможен, то создаётся исключение класса
    `LocalJumpError`. Таким образом, поведение `return` в блоке-аргументе
    полностью аналогично поведению `return` в обычном блоке.

    Выполненние `return` в блоке-аргументе `lambda` приводит к возврату из
    этого блока, что аналогично поведению `return` в методе.

3.  Результат вызова метода `lambda?`: для результата `proc` метод возвратит
    булево значение `false`, а для результата `lambda` — булево значение
    `true`.

### Q2

**Вопрос**. Чем отличается `&&` от `and`?

**Ответ**. Несмотря на то, что семантически эти операторы представляют собой
одно и то же, оператор `&&` имеет более высокий приоритет, нежели `and`. Более
того, между ними в [таблице приоритетов операторов
Ruby](https://ruby-doc.org/core-2.5.3/doc/syntax/precedence_rdoc.html)
находятся и другие важные операторы (например, `=`), что приводит к большой
путанице при использовании `and`. Так, выражение
```ruby
a = b and c
```

фактически означает
```ruby
(a = b) and c
```

что сильно сбивает с толку.

### Q3

**Вопрос**. Какие плюсы и минусы по сравнению с другими современными языками
программирования вы выделяете для себя?

**Ответ**. Плюсы:
*   красивый, лаконичный синтаксис;
*   мощные инструменты объектно-ориентированного программирования и
    метапрограммирования;
*   достаточно богатая коллекция встроенных классов и классов стандартной
    бибилотеки;
*   достаточно большое количество готовых библиотек для решения задач при
    написании сетевых сервисов.

Минусы:
*   медлительность стандартного интерпретатора (например, каждый вызов метода —
    это поиск в одной или нескольких хэш-таблицах), отсутствие в нём
    JIT-компиляции;
*   прожорливость стандартного интерпретатора в плане потребления памяти
    (например, массив из миллиона попарно различных UUID занимает 81 мегабайт
    памяти, что в почти в два раза больше, чем в C или в Go);
*   громоздкость многопоточной модели стандартного интерпретатора (глобальная
    блокировка интерпретатора в модели синхронизации потоков, невозможность
    запуска потоков на различных ядрах вычислительного устройства, каждый
    объект класса `Thread` занимает мегабайт памяти и так далее);
*   использование в подавляющем большинстве случаев только для написания
    сетевых сервисов;
*   сведение всей разработки к разработке под Rails;
*   низкий порог вхождения.

### Q4

**Вопрос**. В каком случае вы бы стали использовать Ruby on Rails для
разработки web-приложения, а в каком случае — другой фреймворк?

**Ответ**. Я бы использовал Ruby on Rails в том случае, если нужно написать
большое web-приложение, предоставляющее пользователю сложный графический
интерфейс. Такие приложения обычно требуют специальных механизмов (например,
обработку cookie, работу с электронными письмами и так далее), которые идут
непосредственно в поставке Rails. Примеры подобных web-приложений:
интернет-магазины, сайты новостей, платформы обучения через Интернет.

В случае, если приложение имеет очень простой графический интерфейс или не
имеет графического интерфейса вообще, я бы обратился к другим фреймворкам.
Примеры подобных web-приложений: сервисы домашней или промышленной
автоматизации, приложения сбора информации (опросники), приложения-утилиты
(часы).

### Q5

**Вопрос**. Вы запустили большой и сложный Ruby-скрипт на вашем любимом
дистрибутиве Linux, и в процессе работы он намертво «зависает». Как найти
причину сбоя?

**Ответ**. Для начала я бы добавил `puts` с разными строками здесь и там в
скрипте, чтобы понять, где он зависает. В запущенных случаях использовал бы
интерактивную отладку, например, с помощью библиотеки `byebug`.

### Q6

**Вопрос**. Вы запустили большой и сложный Ruby-скрипт на вашем любимом
дистрибутиве Linux, и в процессе работы он умирает, исчерпав память, хотя,
казалось бы, не должен. Как найти причину сбоя?

**Ответ**. Возможны два варианта причины исчерпания памяти: создание объектов в
слишком больших количествах или создание объектов, которые потребляют слишком
много памяти. В первом случае необходимо искать код, который может во множестве
порождать объекты (например, запрос к базе данных на извлечение записей). Во
втором случае следует искать код, где данные добавляются в экземпляры классов
`String`, `Array`, `Hash` (например, загрузка содержимого файла или добавление
чисел в массивы). В качестве вспомогательных средств можно использовать
возможности модуля `ObjectSpace`:
```ruby
require 'objspace'

count = lambda do |c|
  ObjectSpace.each_object(c).inject(0) { |memo| memo + 1 }
end

memsize = lambda do |c|
  ObjectSpace.each_object(c).inject(0) do |memo, o|
    memo + ObjectSpace.memsize_of(o)
  end
end

puts count[String]
puts memsize[Array]
```

### Q7

**Вопрос**. Некоторые проекты (Rails и не только) мы запускаем под JRuby. Как
вы думаете, почему?

**Ответ**. Считаю, что возможны следующие варианты.
1.  JRuby используется из-за модели потоков Java, которая более эффективна,
    нежели используемая MRI, из-за отсутствия глобальной блокировки
    интерпретатора и эффективного использования потоков операционной системы,
    которые могут распределяться по многим ядрам вычислительного устройства.
2.  JRuby используется из-за AOT- или JIT-компиляции, что позволяет повысить
    скорость выполнения Ruby-кода.
3.  JRuby используется для подключения и использования некоторого Java-кода в
    Ruby-коде. Знаком с подобной ситуацией на примере адаптера системы
    межведомственного электронного взаимодействия: основная библиотека была
    доступна только для Java.

Разумеется, эти варианты нисколько не исключают друг друга.

### Q8

**Вопрос**. Какие плюсы и минусы библиотеки ActiveRecord в Rails вы знаете?
Какие альтернативы существуют? В чём их плюсы и минусы? Какие из них вы
использовали?

**Ответ**. Кроме ActiveRecord, в профессиональной деятельности я использовал
библиотеки Sequel и DataMapper, наиболее знаком с Sequel.

DataMapper уже несколько лет не поддерживается сообществом, что является его
основным минусом. Механизм автомиграций DataMapper, возможно, был плюсом для
новичков, но в больших проектах всё равно приходилось использовать миграции
базы данных.

Основными плюсами ActiveRecord является его поставка с Rails и интеграция с ним
многих библиотек (все эти `has_secure_password` в модели пользователя). Из
минусов хотел бы отметить следующее:
*   недостаточность библиотеки составления запросов Arel, что приводит к тому,
    что использование SQL-текста для построения запросов быстрее и проще;
*   недостаточность средств для написания миграций, что приводит к тому, что
    приходится писать SQL;
*   бесполезный файл `db/schema.rb`;
*   слабая поддержка специфичных команд СУБД, например, `NOTIFY`/`LISTEN` у
    PostgreSQL.

В Sequel я нахожу всё то, чего мне не хватает в ActiveRecord, и в нём нет
`db/schema.rb`. DSL для создания запросов и миграций в Sequel — это его большой
плюс. Также в Sequel отличная поддержка специфичных для PostgreSQL вещей,
включая вышеупомянутые `NOTIFY`/`LISTEN`, `COPY` и прочее. Из минусов могу
отметить отвратный исходный код, в котором иногда сам чёрт ногу сломит.

## Level II

### Q1

**Постановка задачи и вопросы**. Есть Rails-приложение, развёрнутое на N
серверах. В приложение нужно добавить загрузку и хранение аватаров.

1.  Какую библиотеку использовать?
2.  Куда складывать аватарки и почему?
3.  Как и зачем нужно обрабатывать загружаемые аватарки?
4.  Какие проверки загружаемого файла и когда (например, на клиенте, в Nginx
    или Rails) лучше всего производить?
5.  Как отдавать аватарки пользователю? Какие плюсы и минусы описанного
    подхода?
6.  Какие ещё проблемы и вопросы могут возникнуть при реализации такой
    функциональности?

**Предварительные размышления по поводу решения задачи**. Можно с уверенностью
предположить, хоть об этом и не упомянуто в постановке задачи, что
Rails-приложение подключено к общей для всех N серверов базе данных. Чаще всего
в связке с Rails используют СУБД, хорошо зарекомендовавшие себя с точки зрения
производительности и надёжности, например, те же MySQL или PostgreSQL. Таким
образом, можно предположить, что в связке c Rails используется СУБД, отвечающая
требованиям ACID.

**Ответы на вопросы**.

1.  Для обработки изображений (см. пункт 3) понадобится библиотека,
    предоставляющая доступ к возможностям ImageMagick или GraphicsMagick.
    Подобную функциональность предоставляет библиотека
    [MiniMagick](https://github.com/minimagick/minimagick). Иных дополнительных
    библиотек не понадобится.

2.  Аватарки можно сохранять в таблице в базе данных в виде байтовых строк
    содержимого файлов их изображений. При этом в этой таблице можно сохранять
    в отдельных колонках аватарки с различной обработкой (см. пункт 3). Таблица
    должна также содержать колонку со внешним ключом, ссылающимся на первичный
    ключ таблицы пользователей, поддерживающим каскадные удаление и обновление.
    Такой подход обеспечивает синхронизацию сохранённых аватарок между всеми
    серверами и целостность данных (например, при удалении записи пользователя
    удалятся и его аватары). Кроме того, резервное копирование базы данных
    сохранит и аватары пользователей.

3.  Обработка загруженного пользователем аватара необходима, чтобы уменьшить
    размер сохраняемых изображений. Кроме того, аватары могут иметь различный
    размер в различных местах графического интерфейса пользователя. Потому
    имеет смысл создать и сохранить несколько копий аватара с различными
    настройками обработки. Обработка должна поддерживать следующие настройки:
    *   изменение размера с сохранением соотношений сторон;
    *   перевод изображения в JPEG-формат;
    *   выставление чередования цветовых каналов;
    *   выставление качества изображения;
    *   удаление из файла изображения всех комментариев и вспомогательных
        данных.

    Кроме того, перед обработкой необходимо проверить, является ли
    обрабатываемое изображением корректным изображением в правильном формате.

    Проверку и обработку можно осуществить с помощью утилиты `mogrify` из
    комплексов ImageMagick или GraphicsMagick. Утилитой можно воспользоваться
    непосредственно или с помощью библиотеки, упомянутой в пункте 1. В любом
    случае утилита работает с файлом, потому перед обработкой полученное
    изображение необходимо сохранить в файл, а после обработки — загрузить из
    файла.

4.  Проверки необходимы в следующих частях программного комплекса:
    *   браузерное приложение: проверки на максимальные ширину и высоту, а
        также проверка на максимальный размер загружаемого файла;
    *   обратный прокси/балансировщик перед Rails-приложением: проверка на
        максимальную длину тела запроса на загрузку аватара;
    *   Rails-приложение: проверка, является ли содержимое запроса на
        загрузку аватара корректным изображением (см. также пункт 3);
    *   СУБД: ограничения на максимальный размер полей с содержимым файлов
        аватаров.

5.  Можно рассмотреть следующие варианты.
    *   Добавление в API нового GET-запроса, в теле ответа на который
        непосредственно передаётся содержимое файла аватара. Плюсы заключаются
        в отсутствии преобразований и простоте бизнес-логики. Минус такого
        подхода в том, что для извлечения аватара нужно делать дополнительный
        запрос, а если копий несколько (возможность этого обсуждалась в пункте
        2), то и запросов нужно сделать несколько.

    *   Добавление в API нового GET-запроса, в теле ответа на который
        передаётся содержимое файла аватара в формате `multipart/form-data`.
        Плюс заключается в том, что таким образом можно передать все копии
        аватара за один запрос. Основной минус в том, что для составления тела
        ответа понадобятся [дополнительные память и копирование
        данных](https://github.com/rack/rack/blob/master/lib/rack/multipart/generator.rb#L18-L27).
        Кроме того, по-прежнему надо делать дополнительный запрос.

    *   Добавление поля с содержимым файла или файлов аватара в результат
        запроса на информацию о пользователе. В таком случае не нужно делать
        дополнительных запросов (что является плюсом), но придётся усложнить
        бизнес-логику извлечения информации о пользователе (что является
        минусом). Опять же, составление тела ответа потребует дополнительных
        памяти и копирования данных. Кроме того, если информация о пользователе
        передаётся в каком-то популярном текстовом формате (например, JSON), то
        тело файла придётся преобразовать, например, в формат Base64.

6.  Могут возникнуть следующие проблемы.
    *   Большое количество запросов на загрузку аватара, возникшее из-за ошибки
        или по злому умыслу. Проблема может быть решена настройкой обратного
        прокси/балансировщика.
    *   Повышенная нагрузка на сервера с Rails-приложениями, вызванная работой
        с файлами изображений и утилитой `mogrify`.
    *   Большая нагрузка на СУБД и канал связи с ней. Проблема может быть
        решена с помощью системы кэширования.
    *   Вообще говоря, СУБД никак не должна проверять, является ли байтовая
        строка в поле таблицы аватарок содержимым файла изображения. Таким
        образом, на уровне базы данных можно записать в качестве содержимого
        то, что никак не является изображением.

### Q2

**Постановка задачи и вопрос**. Есть большое приложение с десятками тысяч
тестов. Как лучше всего организовать код и тесты, чтобы добиться максимальной
скорости прогона тестов?

**Ответ**. Я бы попробовал осуществить следующую организацию тестов.
1.  Создание леса зависимостей функционала и отнесение тестов и файлов
    исходного кода к его узлам. Например, бизнес-логика зависит от моделей, а
    контроллеры запросов — от бизнес-логики, потому если поменяются модели, то
    надо протестировать и модели, и бизнес-логику, и контроллеры, а если
    поменяются только контроллеры, то тестировать модели и бизнес-логику нет
    смысла.
2.  Распараллеливание тестов, относящихся к разным деревьям леса зависимостей.
    Если несколько деревьев зависят от одной базы данных, то поднимать
    несколько тествовых баз данных для их прогона.
3.  Выделение правил, относящихся к прогону тестов. Например, при создании
    запроса на слияние ветки разработчика в `develop`-ветку следует прогонять
    только тесты функционала, затронутого по лесу зависимостей, а при создании
    релиза — все тесты.

## Level III

### Q1

Решение задачи можно найти в [моём
репозитории](https://github.com/venomspawn/funbox-nmax-ruby).

### Q2

Решение задачи можно найти в [другом моём
репозитории](https://github.com/venomspawn/funbox-drate).
